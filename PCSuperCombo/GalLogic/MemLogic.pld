/* Implements glue logic. */
Name     MemLogic;
PartNo   PCSC ;
Date     10/10/2021 ;
Revision 01 ;
Designer Jayeson Lee-Steere ;
Company  Titanium Studios Pty Ltd ;
Assembly None ;
Location  ;
Device   G16V8AS;

/* *************** INPUT PINS *********************/
PIN  1  = BASE_RAM_0	         ; /* Base RAM jumper */
PIN  2  = BASE_RAM_1             ; /* Base RAM jumper */
PIN  3  = BASE_RAM_2             ; /* Base RAM jumper */
PIN  4  = UMB_0                  ; /* UMB jumper 0 */
PIN  5  = UMB_1                  ; /* UMB jumper 1 */
PIN  6  = A15                    ; /* ISA address line */
PIN  7  = A16                    ; /* ISA address line */
PIN  8  = A17                    ; /* ISA address line */
PIN  9  = A18                    ; /* ISA address line */
PIN 11  = A19                    ; /* ISA address line */
PIN 12  = RESET_IN               ; /* BUS RESET signal */
PIN 19  = ROM_ADDR               ; /* Rom address jumper */

/* *************** OUTPUT PINS *********************/
PIN 13  = !CS_RAM_0              ; /* ~CS for main RAM IC. */
PIN 14  = !CS_RAM_1              ; /* ~CS for secondary RAM IC. */
PIN 15  = !MEM_DECODED           ; /* If any memory devices has been selected. */
PIN 16  = !CE_BIOS               ; /* ~CE for the BIOS ROM */
PIN 17  = !RESET_OUT             ; /* For inverting reset signal */
PIN 18  = PTERMS_SPARE           ; /* Spare output. Might be needed for address line mods. */

/* Equations */
/* Memory regions. */
DECODE_0000_128 = !A19 & !A18 & !A17; 
DECODE_2000_128 = !A19 & !A18 & A17;
DECODE_4000_128 = !A19 & A18 & !A17;
DECODE_6000_128 = !A19 & A18 & A17;
DECODE_8000_128 = A19 & A18 & A17;

DECODE_1000_64 = !A19 & !A18 & !A17 & A16;

DECODE_C800_32 = A19 & A18 & !A17 & !A16 & A15;
DECODE_D000_32 = A19 & A18 & !A17 &  A16 & !A15;
DECODE_D800_32 = A19 & A18 & !A17 &  A16 & A15;
DECODE_E000_32 = A19 & A18 & A17 & !A16 & !A15;
DECODE_E800_32 = A19 & A18 & A17 & !A16 & A15;

/* RAM 0 decode */
/* Size is existing RAM size, not RAM added */
64K_JUMPER = !BASE_RAM_0 & !BASE_RAM_1 & !BASE_RAM_2;
128K_JUMPER = !BASE_RAM_0 & !BASE_RAM_1 & BASE_RAM_2;
256K_JUMPER = !BASE_RAM_0 & BASE_RAM_1 & !BASE_RAM_2;
384K_JUMPER = !BASE_RAM_0 & BASE_RAM_1 & BASE_RAM_2;
512K_JUMPER = BASE_RAM_0 & !BASE_RAM_1 & !BASE_RAM_2;
T128K_JUMPER = BASE_RAM_0 & !BASE_RAM_1 & BASE_RAM_2; /* Tandy 1000 */
T384K_JUMPER = BASE_RAM_0 & BASE_RAM_1 & !BASE_RAM_2; /* Tandy 1000 */
DISABLED_JUMPER = BASE_RAM_0 & BASE_RAM_1 & BASE_RAM_2;

DECODE_00_128K = (DECODE_0000_128 & T128K_JUMPER) # (T128K_JUMPER & (64K_JUMPER # 128K_JUMPER # 256K_JUMPER # 384K_JUMPER # 512K_JUMPER));
DECODE_01_128K = DECODE_2000_128 & (64K_JUMPER # 128K_JUMPER # T128K_JUMPER);
DECODE_10_128K = DECODE_4000_128 & (64K_JUMPER # 128K_JUMPER # 256K_JUMPER # T128K_JUMPER # T384K_JUMPER);
DECODE_11_128K = DECODE_6000_128 & (64K_JUMPER # 128K_JUMPER # 256K_JUMPER # 384K_JUMPER # T128K_JUMPER # T384K_JUMPER);

CS_RAM_0_TEMP = DECODE_00_128K # DECODE_01_128K # DECODE_10_128K # DECODE_11_128K;

/* BIOS decode */
BIOS_C800 = !ROM_ADDR;
BIOS_D000 = ROM_ADDR;
CE_BIOS_TEMP = (BIOS_C800 & DECODE_C800_32) # (BIOS_D000 & DECODE_D000_32);

/* RAM 1 decode */ 
UMB_LARGE = !UMB_0 & !UMB_1;
UMB_SMALL_LOW = !UMB_0 & UMB_1;
UMB_SMALL_HIGH = UMB_0 & !UMB_1;

UMB_C800_LARGE = BIOS_C800 & UMB_LARGE & (DECODE_D000_32 # DECODE_D800_32 # DECODE_E000_32 # DECODE_E800_32);
UMB_C800_SMALL_LOW = BIOS_C800 & UMB_SMALL_LOW & (DECODE_D000_32 # DECODE_D800_32);
UMB_C800_SMALL_HIGH = BIOS_C800 & UMB_SMALL_HIGH & (DECODE_E000_32 # DECODE_E800_32);
UMB_D000_LARGE = BIOS_D000 & UMB_LARGE & (DECODE_D800_32 # DECODE_E000_32 # DECODE_E800_32);
UMB_D000_SMALL_LOW = BIOS_D000 & UMB_SMALL_LOW & (DECODE_D800_32 # DECODE_E000_32);
UMB_D000_SMALL_HIGH = BIOS_D000 & UMB_SMALL_HIGH & (DECODE_E000_32 # DECODE_E800_32);
DECODE_BASE_64K = DECODE_1000_64 & 64K_JUMPER; /* Only C800_SMALL_LOW is valid when using the extra 64K of memory for base RAM */

CS_RAM_1_TEMP = UMB_C800_LARGE # UMB_C800_SMALL_LOW # UMB_C800_SMALL_HIGH # UMB_D000_LARGE # UMB_D000_SMALL_LOW # UMB_D000_SMALL_HIGH # DECODE_BASE_64K;

/* Outputs */
RESET_OUT = RESET_IN; /* For inversion only */
CS_RAM_0 = CS_RAM_0_TEMP;
CS_RAM_1 = CS_RAM_1_TEMP;
CE_BIOS = CE_BIOS_TEMP;
MEM_DECODED = CS_RAM_0_TEMP # CS_RAM_1 # CE_BIOS_TEMP;

/*
CE_BIOS_DECODE_TEMP = DECODE_C000;

BASE_RAM_DECODE_1ST_128 = !A19 & !A18 & !A17 & BASE_RAM_SIZE;
BASE_RAM_DECODE_2ND_128 = !A19 & !A18 & A17;
BASE_RAM_DECODE_3RD_128 = !A19 & A18 & !A17;
BASE_RAM_DECODE = (BASE_RAM_DECODE_1ST_128 # BASE_RAM_DECODE_2ND_128 # BASE_RAM_DECODE_3RD_128) & BASE_RAM_ENABLE;

UMB_DECODE_C800 = DECODE_C800;
UMB_DECODE_D000 = DECODE_D000;
UMB_DECODE_D800 = DECODE_D800;
UMB_DECODE_E000 = DECODE_E000 & !UMB_SIZE;
UMB_DECODE_E800 = DECODE_E800 & !UMB_SIZE & !BASE_RAM_SIZE;
UMB_DECODE_TEMP = (UMB_DECODE_C800 # UMB_DECODE_D000 # UMB_DECODE_D800 # UMB_DECODE_E000 # UMB_DECODE_E800) & UMB_ENABLE;

CE_RAM_DECODE_TEMP = BASE_RAM_DECODE # UMB_DECODE_TEMP;

MEMR_DECODE_TEMP = (CE_BIOS_DECODE_TEMP # CE_RAM_DECODE_TEMP) & MEMR;

A17_MAPPED_TEMP = (DECODE_C800 # DECODE_D000 # DECODE_D800) $ A17;
A18_MAPPED_TEMP = DECODE_E800 $ A18;

BUF_READ_TEMP = MEMR_DECODE_TEMP # IOR_DECODE;
*/

/* Outputs */
/*A17_MAPPED = A17_MAPPED_TEMP;
A18_MAPPED = A18_MAPPED_TEMP;
CE_RAM_DECODE = CE_RAM_DECODE_TEMP;
CE_BIOS_DECODE = CE_BIOS_DECODE_TEMP;
*/
